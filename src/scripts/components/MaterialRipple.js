'use strict';
/**
 * Class constructor for Ripple MDL component.
 * Implements MDL component design pattern defined at:
 * https://github.com/jasonmayes/mdl-component-design-pattern
 */
export default class MaterialRipple {
  /**
   * @constructor
   * @param {HTMLElement} element The element that will be upgraded.
   */
  constructor(element) {
    this.element_ = element;
    // Initialize instance.
    this.init();
  }

  /**
   * Store constants in one place so they can be updated easily.
   *
   * @enum {string | number}
   * @private
   */
  static get Constant_() {
    return {
      INITIAL_SCALE: 'scale(0.0001, 0.0001)',
      INITIAL_SIZE: '1px',
      INITIAL_OPACITY: '0.4',
      FINAL_OPACITY: '0',
      FINAL_SCALE: ''
    };
  }

  /**
   * Store strings for class names defined by this component that are used in
   * JavaScript. This allows us to simply change it in one place should we
   * decide to modify at a later date.
   *
   * @enum {string}
   * @private
   */
  static get CssClasses_() {
    return {
      RIPPLE: 'ripple',
      IS_ANIMATING: 'is-animating',
      IS_VISIBLE: 'is-visible'
    };
  }

  /**
   * Handle mouse / finger down on element.
   *
   * @param {Event} event The event that fired.
   * @private
   */
  downHandler_(event) {
    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
      const rect = this.element_.getBoundingClientRect();
      this.boundHeight = rect.height;
      this.boundWidth = rect.width;
      this.rippleSize_ = Math.sqrt(rect.width * rect.width + rect.height * rect.height) * 2 + 2;
      this.rippleElement_.style.width = this.rippleSize_ + 'px';
      this.rippleElement_.style.height = this.rippleSize_ + 'px';
    }
    this.rippleElement_.classList.add(MaterialRipple.CssClasses_.IS_VISIBLE);
    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
      this.ignoringMouseDown_ = false;
    } else {
      if (event.type === 'touchstart') {
        this.ignoringMouseDown_ = true;
      }
      const frameCount = this.getFrameCount();
      if (frameCount > 0) {
        return;
      }
      this.setFrameCount(1);
      const bound = event.currentTarget.getBoundingClientRect();
      let x;
      let y;
      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        const clientX = event.clientX ? event.clientX : event.touches[0].clientX;
        const clientY = event.clientY ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      this.setRippleXY(x, y);
      this.setRippleStyles(true);
      window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }
  }

  /**
   * Handle mouse / finger up on element.
   *
   * @param {Event} event The event that fired.
   * @private
   */
  upHandler_(event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      this.rippleElement_.classList.remove(MaterialRipple.CssClasses_.IS_VISIBLE);
    }
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    requestAnimationFrame(() => {
      this.rippleElement_.classList.remove(MaterialRipple.CssClasses_.IS_VISIBLE);
    });
  }

  /**
   * Initialize element.
   */
  init() {
    if (this.element_) {
      this.rippleElement_ = this.element_.querySelector('.' + MaterialRipple.CssClasses_.RIPPLE);
      this.frameCount_ = 0;
      this.rippleSize_ = 0;
      this.x_ = 0;
      this.y_ = 0;
      // Touch start produces a compat mouse down event, which would cause a
      // second ripples. To avoid that, we use this property to ignore the first
      // mouse down after a touch start.
      this.ignoringMouseDown_ = false;
      this.boundDownHandler = this.downHandler_.bind(this);
      this.element_.addEventListener('mousedown', this.boundDownHandler);
      this.element_.addEventListener('touchstart', this.boundDownHandler);
      this.boundUpHandler = this.upHandler_.bind(this);
      this.element_.addEventListener('mouseup', this.boundUpHandler);
      this.element_.addEventListener('mouseleave', this.boundUpHandler);
      this.element_.addEventListener('touchend', this.boundUpHandler);
      this.element_.addEventListener('blur', this.boundUpHandler);
      /**
       * Getter for frameCount_.
       * @return {number} the frame count.
       */
      this.getFrameCount = function() {
        return this.frameCount_;
      };
      /**
       * Setter for frameCount_.
       * @param {number} fC the frame count.
       */
      this.setFrameCount = function(fC) {
        this.frameCount_ = fC;
      };
      /**
       * Getter for rippleElement_.
       * @return {Element} the ripple element.
       */
      this.getRippleElement = function() {
        return this.rippleElement_;
      };
      /**
       * Sets the ripple X and Y coordinates.
       * @param{number} newX the new X coordinate
       * @param{number} newY the new Y coordinate
       */
      this.setRippleXY = function(newX, newY) {
        this.x_ = newX;
        this.y_ = newY;
      };
      /**
       * Sets the ripple styles.
       * @param{boolean} start whether or not this is the start frame.
       */
      this.setRippleStyles = function(start) {
        if (this.rippleElement_ !== null) {
          let scale;
          let size;
          const offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';
          if (start) {
            scale = MaterialRipple.Constant_.INITIAL_SCALE;
            size = MaterialRipple.Constant_.INITIAL_SIZE;
          } else {
            scale = MaterialRipple.Constant_.FINAL_SCALE;
            size = this.rippleSize_ + 'px';
          }
          const transformString = 'translate(-50%, -50%) ' + offset + scale;
          this.rippleElement_.style.webkitTransform = transformString;
          this.rippleElement_.style.msTransform = transformString;
          this.rippleElement_.style.transform = transformString;
          if (start) {
            this.rippleElement_.classList.remove(MaterialRipple.CssClasses_.IS_ANIMATING);
          } else {
            this.rippleElement_.classList.add(MaterialRipple.CssClasses_.IS_ANIMATING);
          }
        };
        /**
         * Handles an animation frame.
         */
        this.animFrameHandler = function() {
          if (this.frameCount_-- > 0) {
            window.requestAnimationFrame(this.animFrameHandler.bind(this));
          } else {
            this.setRippleStyles(false);
          }
        };
      }
    }
  }

  /**
   * Downgrade the component
   *
   * @private
   */
  mdlDowngrade_() {
    this.element_.removeEventListener('mousedown', this.boundDownHandler);
    this.element_.removeEventListener('touchstart', this.boundDownHandler);
    this.element_.removeEventListener('mouseup', this.boundUpHandler);
    this.element_.removeEventListener('mouseleave', this.boundUpHandler);
    this.element_.removeEventListener('touchend', this.boundUpHandler);
    this.element_.removeEventListener('blur', this.boundUpHandler);
  }
}
